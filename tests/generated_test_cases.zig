const std = @import("std");

const CASES_DIR = "cases";
const MAX_BYTES = 1 << 20; // 1 MiB

/// Generated test case containing input and expected output data.
/// Generated by ./generate_test_cases.py
pub const TestCase = struct {
    name: []const u8,
    blocks_bytes: []u8,
    scales_bytes: []u8,
    f32: []f32,
};

pub fn load(arena: *std.heap.ArenaAllocator) !std.ArrayList(TestCase) {
    const alloc = arena.allocator();

    var dir = try std.fs.cwd().openDir(CASES_DIR, .{ .iterate = true });
    defer dir.close();

    var it = dir.iterate();
    var cases = try std.ArrayList(TestCase).initCapacity(alloc, 32);
    while (try it.next()) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.endsWith(u8, entry.name, ".f32.bin")) continue;
        const f32_filename = entry.name;
        const name = try alloc.dupe(u8, f32_filename[0 .. f32_filename.len - ".f32.bin".len]);
        const f32_bytes = try dir.readFileAllocOptions(alloc, f32_filename, MAX_BYTES, null, .of(f32), null);
        if (f32_bytes.len % 4 != 0) {
            @panic("f32 file length is not a multiple of 4");
        }
        const f32_data: []f32 = std.mem.bytesAsSlice(f32, f32_bytes);

        const scales_filename = try std.mem.concat(alloc, u8, &.{ name, ".scales.bin" });
        defer alloc.free(scales_filename);
        const scales_bytes = try dir.readFileAlloc(alloc, scales_filename, MAX_BYTES);
        if (scales_bytes.len * 32 != f32_data.len) {
            @panic("scales file length does not match f32 data length");
        }

        const blocks_filename = try std.mem.concat(alloc, u8, &.{ name, ".blocks.bin" });
        defer alloc.free(blocks_filename);
        const blocks_bytes = try dir.readFileAlloc(alloc, blocks_filename, MAX_BYTES);
        if (blocks_bytes.len * 2 != f32_data.len) {
            @panic("blocks file length does not match f32 data length");
        }

        try cases.append(alloc, TestCase{
            .name = name,
            .blocks_bytes = blocks_bytes,
            .scales_bytes = scales_bytes,
            .f32 = f32_data,
        });
    }

    return cases;
}

/// Expected values for each test case.
pub const ExpectedValues = struct {
    case_name_to_values: std.StringHashMap([]f32),
};

pub fn loadExpectedValues(arena: *std.heap.ArenaAllocator) !ExpectedValues {
    const arena_alloc = arena.allocator();

    var dir = try std.fs.cwd().openDir(CASES_DIR, .{});
    defer dir.close();

    const manifest_bytes = try dir.readFileAlloc(arena_alloc, "expected_values.json", MAX_BYTES);

    var parsed = try std.json.parseFromSlice(std.json.Value, arena_alloc, manifest_bytes, .{});
    defer parsed.deinit();
    try std.testing.expect(parsed.value == .object);

    var map = std.StringHashMap([]f32).init(arena_alloc);
    var it = parsed.value.object.iterator();
    while (it.next()) |entry| {
        const key = entry.key_ptr.*;
        const value = entry.value_ptr.*;
        if (value != .array) return error.InvalidManifestEntry;

        const items = value.array.items;
        const values = try arena_alloc.alloc(f32, items.len);
        for (items, 0..) |item, idx| {
            values[idx] = switch (item) {
                .float => @floatCast(item.float),
                .integer => @floatFromInt(item.integer),
                else => return error.InvalidManifestValue,
            };
        }

        try map.put(try arena_alloc.dupe(u8, key), values);
    }

    return ExpectedValues{ .case_name_to_values = map };
}
